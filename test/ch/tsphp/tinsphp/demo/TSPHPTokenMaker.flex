/*
 * TSPHPTokenMaker.java - Generates tokens for TSPHP syntax highlighting.
 *
 * - Use in conjunction with the skeleton.default.
 * - use --legacydot
 * command as follows:
    jflex -skel skeleton.default TSPHPTokenMaker.flex

 * - Additionally, the following:
    zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);
    zzCurrentPosL += Character.charCount(zzInput);

 * needs to be replaced with
    zzInput = zzBufferL[zzCurrentPosL++];

 *
 * Based on the following TokenMaker:
 */

 /*
 *
 * 01/28/2009
 *
 * PHPTokenMaker.java - Generates tokens for PHP syntax highlighting.
 *
 * This library is distributed under a modified BSD license.  See the included
 * RSyntaxTextArea.License.txt file for details.
 */
package ch.tsphp.tinsphp.demo;

import java.io.*;
import javax.swing.text.Segment;

import org.fife.ui.rsyntaxtextarea.*;
import org.fife.ui.rsyntaxtextarea.modes.AbstractMarkupTokenMaker;


/**
 * Scanner for PHP files.
 *
 * This implementation was created using
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.1; however, the generated file
 * was modified for performance.  Memory allocation needs to be almost
 * completely removed to be competitive with the handwritten lexers (subclasses
 * of <code>AbstractTokenMaker</code>, so this class has been modified so that
 * Strings are never allocated (via yytext()), and the scanner never has to
 * worry about refilling its buffer (needlessly copying chars around).
 * We can achieve this because RText always scans exactly 1 line of tokens at a
 * time, and hands the scanner this line as an array of characters (a Segment
 * really).  Since tokens contain pointers to char arrays instead of Strings
 * holding their contents, there is no need for allocating new memory for
 * Strings.<p>
 *
 * The actual algorithm generated for scanning has, of course, not been
 * modified.<p>
 *
 * If you wish to regenerate this file yourself, keep in mind the following:
 * <ul>
 *   <li>The generated <code>PHPTokenMaker.java</code> file will contain two
 *       definitions of both <code>zzRefill</code> and <code>yyreset</code>.
 *       You should hand-delete the second of each definition (the ones
 *       generated by the lexer), as these generated methods modify the input
 *       buffer, which we'll never have to do.</li>
 *   <li>You should also change the declaration/definition of zzBuffer to NOT
 *       be initialized.  This is a needless memory allocation for us since we
 *       will be pointing the array somewhere else anyway.</li>
 *   <li>You should NOT call <code>yylex()</code> on the generated scanner
 *       directly; rather, you should use <code>getTokenList</code> as you would
 *       with any other <code>TokenMaker</code> instance.</li>
 * </ul>
 *
 * @author Robert Futrell
 * @version 0.9
 */
%%

%public
%class TSPHPTokenMaker
%extends AbstractMarkupTokenMaker
%unicode
%type org.fife.ui.rsyntaxtextarea.Token


%{


	/**
	 * Token type specifying we're in PHP.  This particular field is public so
	 * that we can hack and key off of it for code completion.
	 */
	public static final int INTERNAL_IN_PHP					= -(4<<11);

	/**
	 * Token type specifying we're in a PHP multiline comment.
	 */
	private static final int INTERNAL_IN_PHP_MLC				= -(5<<11);

	/**
	 * Token type specifying we're in a PHP multiline string.
	 */
	private static final int INTERNAL_IN_PHP_STRING				= -(6<<11);

	/**
	 * Token type specifying we're in a PHP multiline char.
	 */
	private static final int INTERNAL_IN_PHP_CHAR				= -(7<<11);

	/**
	 * Whether closing markup tags are automatically completed for PHP.
	 */
	private static boolean completeCloseTags;

	/**
	 * The state PHP was started in (YYINITIAL, INTERNAL_IN_JS, etc.).
	 */
	private int phpInState;

	/**
	 * The language index we were in when PHP was started.
	 */
	private int phpInLangIndex;

	/**
	 * Language state set on PHP.
	 */
	private static final int LANG_INDEX_PHP = 3;


	/**
	 * Constructor.  This must be here because JFlex does not generate a
	 * no-parameter constructor.
	 */
	public TSPHPTokenMaker() {
		super();
	}


	/**
	 * Adds the token specified to the current linked list of tokens as an
	 * "end token;" that is, at <code>zzMarkedPos</code>.
	 *
	 * @param tokenType The token's type.
	 */
	private void addEndToken(int tokenType) {
		addToken(zzMarkedPos,zzMarkedPos, tokenType);
	}


	/**
	 * Adds the token specified to the current linked list of tokens.
	 *
	 * @param tokenType The token's type.
	 * @see #addToken(int, int, int)
	 */
	private void addHyperlinkToken(int start, int end, int tokenType) {
		int so = start + offsetShift;
		addToken(zzBuffer, start,end, tokenType, so, true);
	}


	/**
	 * Adds an end token that encodes the information necessary to return
	 * to the pre-PHP state and language index.
	 *
	 * @param endTokenState The PHP-related end-token state.
	 */
	private void addPhpEndToken(int endTokenState) {
		addEndToken(endTokenState - phpInState - (phpInLangIndex<<16));
	}


	/**
	 * Adds the token specified to the current linked list of tokens.
	 *
	 * @param tokenType The token's type.
	 */
	private void addToken(int tokenType) {
		addToken(zzStartRead, zzMarkedPos-1, tokenType);
	}


	/**
	 * Adds the token specified to the current linked list of tokens.
	 *
	 * @param tokenType The token's type.
	 */
	private void addToken(int start, int end, int tokenType) {
		int so = start + offsetShift;
		addToken(zzBuffer, start,end, tokenType, so);
	}


	/**
	 * Adds the token specified to the current linked list of tokens.
	 *
	 * @param array The character array.
	 * @param start The starting offset in the array.
	 * @param end The ending offset in the array.
	 * @param tokenType The token's type.
	 * @param startOffset The offset in the document at which this token
	 *                    occurs.
	 */
	@Override
	public void addToken(char[] array, int start, int end, int tokenType, int startOffset) {
		super.addToken(array, start,end, tokenType, startOffset);
		zzStartRead = zzMarkedPos;
	}


	/**
	 * {@inheritDoc}
	 */
	@Override
	protected OccurrenceMarker createOccurrenceMarker() {
		return new HtmlOccurrenceMarker();
	}


	/**
	 * Sets whether markup close tags should be completed.  You might not want
	 * this to be the case, since some tags in standard HTML aren't usually
	 * closed.
	 *
	 * @return Whether closing markup tags are completed.
	 * @see #setCompleteCloseTags(boolean)
	 */
	@Override
	public boolean getCompleteCloseTags() {
		return completeCloseTags;
	}


	@Override
    public boolean getCurlyBracesDenoteCodeBlocks(int languageIndex) {
        return languageIndex==LANG_INDEX_PHP;
    }


	/**
	 * {@inheritDoc}
	 */
	@Override
    public String[] getLineCommentStartAndEnd(int languageIndex) {
        return new String[] { "//", null };
    }


	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean getMarkOccurrencesOfTokenType(int type) {
		return type==Token.FUNCTION || type==Token.VARIABLE ||
				type==Token.MARKUP_TAG_NAME;
	}


	/**
	 * Overridden to handle newlines in JS and CSS differently than those in
	 * markup.
	 */
	@Override
	public boolean getShouldIndentNextLineAfter(Token token) {
		int languageIndex = token==null ? 0 : token.getLanguageIndex();
		if (getCurlyBracesDenoteCodeBlocks(languageIndex)) {
			if (token!=null && token.length()==1) {
				char ch = token.charAt(0);
				return ch=='{' || ch=='(';
			}
		}
		return false;
	}


	/**
	 * Returns the first token in the linked list of tokens generated
	 * from <code>text</code>.  This method must be implemented by
	 * subclasses so they can correctly implement syntax highlighting.
	 *
	 * @param text The text from which to get tokens.
	 * @param initialTokenType The token type we should start with.
	 * @param startOffset The offset into the document at which
	 *        <code>text</code> starts.
	 * @return The first <code>Token</code> in a linked list representing
	 *         the syntax highlighted text.
	 */
	public Token getTokenList(Segment text, int initialTokenType, int startOffset) {

        resetTokenList();
        this.offsetShift = -text.offset + startOffset;
        phpInState = YYINITIAL; // Shouldn't be necessary

        // Start off in the proper state
        int state;

        if (initialTokenType<-1024) { // INTERNAL_IN_PHPxxx - phpInState
            int main = -(-initialTokenType & 0x0000ff00);
            switch (main) {
                default: // Should never happen
                case INTERNAL_IN_PHP:
                    state = YYINITIAL;
                    phpInState = -initialTokenType&0xff;
                    phpInLangIndex = (-initialTokenType&0x00ff0000)>>16;
                    break;
                case INTERNAL_IN_PHP_MLC:
                    state = PHP_MLC;
                    phpInState = -initialTokenType&0xff;
                    phpInLangIndex = (-initialTokenType&0x00ff0000)>>16;
                    break;
                case INTERNAL_IN_PHP_STRING:
                    state = PHP_STRING;
                    phpInState = -initialTokenType&0xff;
                    phpInLangIndex = (-initialTokenType&0x00ff0000)>>16;
                    break;
                case INTERNAL_IN_PHP_CHAR:
                    state = PHP_CHAR;
                    phpInState = -initialTokenType&0xff;
                    phpInLangIndex = (-initialTokenType&0x00ff0000)>>16;
                    break;
            }
        }
        else {
            state = YYINITIAL;
        }

        setLanguageIndex(LANG_INDEX_PHP);
        start = text.offset;
        s = text;
        try {
            yyreset(zzReader);
            yybegin(state);
            return yylex();
        } catch (IOException ioe) {
            ioe.printStackTrace();
            return new TokenImpl();
        }

    }


	/**
	 * Sets whether markup close tags should be completed.  You might not want
	 * this to be the case, since some tags in standard HTML aren't usually
	 * closed.
	 *
	 * @param complete Whether closing markup tags are completed.
	 * @see #getCompleteCloseTags()
	 */
	public static void setCompleteCloseTags(boolean complete) {
		completeCloseTags = complete;
	}


	/**
	 * Overridden to remember the language index we're leaving.
	 */
	@Override
	protected void yybegin(int state, int languageIndex) {
		phpInLangIndex = getLanguageIndex();
		yybegin(state);
		setLanguageIndex(languageIndex);
	}


%}

// HTML-specific stuff.
Whitespace					= ([ \t\f]+)
LineTerminator				= ([\n])
Identifier					= ([^ \t\n<&]+)
EntityReference					= ([&][^; \t]*[;]?)
InTagIdentifier				= ([^ \t\n\"\'/=>]+)
EndScriptTag				= ("</" [sS][cC][rR][iI][pP][tT] ">")
EndStyleTag					= ("</" [sS][tT][yY][lL][eE] ">")


// General stuff.
Letter							= [A-Za-z]
NonzeroDigit					= [1-9]
Digit							= ("0"|{NonzeroDigit})
HexDigit						= ({Digit}|[A-Fa-f])
OctalDigit						= ([0-7])
LetterOrUnderscore				= ({Letter}|"_")
LetterOrUnderscoreOrDash		= ({LetterOrUnderscore}|[\-])


// JavaScript stuff.
EscapedSourceCharacter				= ("u"{HexDigit}{HexDigit}{HexDigit}{HexDigit})
NonSeparator						= ([^\t\f\r\n\ \(\)\{\}\[\]\;\,\.\=\>\<\!\~\?\:\+\-\*\/\&\|\^\%\"\']|"#"|"\\")
IdentifierStart					= ({Letter}|"_"|"$")
IdentifierPart						= ({IdentifierStart}|{Digit}|("\\"{EscapedSourceCharacter}))
JS_MLCBegin				= "/*"
JS_MLCEnd					= "*/"
JS_LineCommentBegin			= "//"
JS_IntegerHelper1			= (({NonzeroDigit}{Digit}*)|"0")
JS_IntegerHelper2			= ("0"(([xX]{HexDigit}+)|({OctalDigit}*)))
JS_IntegerLiteral			= ({JS_IntegerHelper1}[lL]?)
JS_HexLiteral				= ({JS_IntegerHelper2}[lL]?)
JS_FloatHelper1			= ([fFdD]?)
JS_FloatHelper2			= ([eE][+-]?{Digit}+{JS_FloatHelper1})
JS_FloatLiteral1			= ({Digit}+"."({JS_FloatHelper1}|{JS_FloatHelper2}|{Digit}+({JS_FloatHelper1}|{JS_FloatHelper2})))
JS_FloatLiteral2			= ("."{Digit}+({JS_FloatHelper1}|{JS_FloatHelper2}))
JS_FloatLiteral3			= ({Digit}+{JS_FloatHelper2})
JS_FloatLiteral			= ({JS_FloatLiteral1}|{JS_FloatLiteral2}|{JS_FloatLiteral3}|({Digit}+[fFdD]))
JS_ErrorNumberFormat		= (({JS_IntegerLiteral}|{JS_HexLiteral}|{JS_FloatLiteral}){NonSeparator}+)
JS_Separator				= ([\(\)\{\}\[\]\]])
JS_Separator2				= ([\;,.])
JS_NonAssignmentOperator		= ("+"|"-"|"<="|"^"|"++"|"<"|"*"|">="|"%"|"--"|">"|"/"|"!="|"?"|">>"|"<<"|"!"|"&"|"=="|":"|">>"|"~"|"||"|"&&"|">>>")
JS_AssignmentOperator		= ("="|"-="|"*="|"/="|"|="|"&="|"^="|"+="|"%="|"<<="|">>="|">>>=")
JS_Operator				= ({JS_NonAssignmentOperator}|{JS_AssignmentOperator})
JS_Identifier				= ({IdentifierStart}{IdentifierPart}*)
JS_ErrorIdentifier			= ({NonSeparator}+)
JS_Regex					= ("/"([^\*\\/]|\\.)([^/\\]|\\.)*"/"[gim]*)
JS_BooleanLiteral			= ("true"|"false")


// PHP stuff (most PHP stuff is shared with JS for simplicity)
PHP_Start					= ("<?""php"?)
LetterOrUnderscoreOrDigit	= ({LetterOrUnderscore}|{Digit})
PHP_Variable				= ("$"{LetterOrUnderscore}{LetterOrUnderscoreOrDigit}*)
PHP_LineCommentBegin		= ("//"|[#])
PHP_BooleanLiteral			= (JS_BooleanLiteral|"TRUE"|"FALSE")
PHP_Null					= ("null"|"NULL")
PHP_PrimitiveTypes          = ("bool"|"int"|"float"|"string"|"array"|"mixed"| "num"|"scalar"|"void"|"nullType"|"falseType"|"trueType")

URLGenDelim				= ([:\/\?#\[\]@])
URLSubDelim				= ([\!\$&'\(\)\*\+,;=])
URLUnreserved			= ({LetterOrUnderscoreOrDigit}|[\-\.\~])
URLCharacter			= ({URLGenDelim}|{URLSubDelim}|{URLUnreserved}|[%])
URLCharacters			= ({URLCharacter}*)
URLEndCharacter			= ([\/\$]|{Letter}|{Digit})
URL						= (((https?|f(tp|ile))"://"|"www.")({URLCharacters}{URLEndCharacter})?)

%state PHP_MLC
%state PHP_STRING
%state PHP_CHAR
%state Function

%%

<YYINITIAL> {

    "<?php"                     { addToken(Token.MARKUP_TAG_DELIMITER);}
    "?>"                        { addToken(Token.MARKUP_TAG_DELIMITER);}

	/* Error control operator */
	("@"{JS_Identifier})		{
									int count = yylength();
									addToken(zzStartRead,zzStartRead, Token.FUNCTION);
									zzMarkedPos -= (count-1); //yypushback(count-1);
								}

	/* Keywords */
	"__CLASS__" |
	"__DIR__" |
	"__FILE__" |
	"__FUNCTION__" |
	"__METHOD__" |
	"__NAMESPACE__" |
	"abstract" |
	"and" |
	"as" |
	"break" |
	"case" |
	"catch" |
	"cfunction" |
	"class" |
	"clone" |
	"const" |
	"continue" |
	"declare" |
	"default" |
	"die" |
	"do" |
	"echo" |
	"else" |
	"elseif" |
	"empty" |
	"enddeclare" |
	"endfor" |
	"endforeach" |
	"endif" |
	"endswitch" |
	"endwhile" |
	"eval" |
	"extends" |
	"final" |
	"for" |
	"foreach" |
	"global" |
	"goto" |
	"if" |
	"implements" |
	"include" |
	"include_once" |
	"interface" |
	"instanceof" |
	"isset" |
	"list" |
	"namespace" |
	"new" |
	"old_function" |
	"or" |
	"print" |
	"private" |
	"protected" |
	"public" |
	"require" |
	"require_once" |
	"static" |
	"switch" |
	"throw" |
	"try" |
	"unset" |
	"use" |
	"var" |
	"while" |
	"xor" |

	"parent" |
	"self" |
	"stdClass"	|
	"where"				        { addToken(Token.RESERVED_WORD); }

	"exit" |
	"return"					{ addToken(Token.RESERVED_WORD_2); }

    {PHP_PrimitiveTypes}        { addToken(Token.DATA_TYPE);}

    "function"                  { addToken(Token.RESERVED_WORD); yybegin(Function);}

	{PHP_BooleanLiteral}		{ addToken(Token.LITERAL_BOOLEAN); }
	{PHP_Null}					{ addToken(Token.RESERVED_WORD); }
	{PHP_Variable}				{ addToken(Token.VARIABLE); }

	{LineTerminator}			{ addPhpEndToken(INTERNAL_IN_PHP); return firstToken; }
	{Whitespace}				{ addToken(Token.WHITESPACE); }

	/* String/Character literals. */
	[\"]						{ start = zzMarkedPos-1; yybegin(PHP_STRING); }
	[\']						{ start = zzMarkedPos-1; yybegin(PHP_CHAR); }

	/* Comment literals. */
	"/**/"						{ addToken(Token.COMMENT_MULTILINE); }
	{JS_MLCBegin}				{ start = zzMarkedPos-2; yybegin(PHP_MLC); }
	{PHP_LineCommentBegin}.*	{ addToken(Token.COMMENT_EOL); addPhpEndToken(INTERNAL_IN_PHP); return firstToken; }

	/* Separators. */
	{JS_Separator}				{ addToken(Token.SEPARATOR); }

	/* Operators. */
	{JS_Operator}				{ addToken(Token.OPERATOR); }

	/* Numbers */
	{JS_IntegerLiteral}			{ addToken(Token.LITERAL_NUMBER_DECIMAL_INT); }
	{JS_HexLiteral}				{ addToken(Token.LITERAL_NUMBER_HEXADECIMAL); }
	{JS_FloatLiteral}			{ addToken(Token.LITERAL_NUMBER_FLOAT); }
	{JS_ErrorNumberFormat}		{ addToken(Token.ERROR_NUMBER_FORMAT); }

    [T][0-9]*                   { addToken(Token.MARKUP_TAG_NAME); }
    [A-Z]{IdentifierPart}*      { addToken(Token.MARKUP_ENTITY_REFERENCE); }
    {JS_Identifier}             { addToken(Token.IDENTIFIER); }

	{JS_ErrorIdentifier}		{ addToken(Token.ERROR_IDENTIFIER); }

	/* Ended with a line not in a string or comment. */
	<<EOF>>						{ addPhpEndToken(INTERNAL_IN_PHP); return firstToken; }

	[^\n]				        { addToken(Token.IDENTIFIER); } // Catches everything.

}

<Function> {
    {Whitespace}				{ addToken(Token.WHITESPACE); }
    [T][0-9]*                   { addToken(Token.MARKUP_TAG_NAME); }
    [A-Z]{IdentifierPart}*      { addToken(Token.MARKUP_ENTITY_REFERENCE); }
    {PHP_PrimitiveTypes}        { addToken(Token.DATA_TYPE);}
    {JS_Identifier}             { addToken(Token.FUNCTION); }
    "<"|">"                     { addToken(Token.OPERATOR); }
    <<EOF>>						{ addPhpEndToken(INTERNAL_IN_PHP); return firstToken; }

    [^\n]				        { addToken(Token.IDENTIFIER); yybegin(YYINITIAL); } // Catches everything.
}


<PHP_MLC> {
	// PHP MLC's.  This state is essentially Java's MLC state.
	[^hwf\n\*]+					{}
	{URL}						{ int temp=zzStartRead; addToken(start,zzStartRead-1, Token.COMMENT_MULTILINE); addHyperlinkToken(temp,zzMarkedPos-1, Token.COMMENT_MULTILINE); start = zzMarkedPos; }
	[hwf]						{}
	\n							{ addToken(start,zzStartRead-1, Token.COMMENT_MULTILINE); addPhpEndToken(INTERNAL_IN_PHP_MLC); return firstToken; }
	{JS_MLCEnd}					{ yybegin(YYINITIAL); addToken(start,zzStartRead+1, Token.COMMENT_MULTILINE); }
	\*							{}
	<<EOF>>						{ addToken(start,zzStartRead-1, Token.COMMENT_MULTILINE); addPhpEndToken(INTERNAL_IN_PHP_MLC); return firstToken; }
}


<PHP_STRING> {
	[^\n\\\$\"]+		{}
	\n					{ addToken(start,zzStartRead-1, Token.LITERAL_STRING_DOUBLE_QUOTE); addPhpEndToken(INTERNAL_IN_PHP_STRING); return firstToken; }
	\\.?				{ /* Skip escaped chars. */ }
	{PHP_Variable}		{ int temp=zzStartRead; addToken(start,zzStartRead-1, Token.LITERAL_STRING_DOUBLE_QUOTE); addToken(temp,zzMarkedPos-1, Token.VARIABLE); start = zzMarkedPos; }
	"$"					{}
	\"					{ yybegin(YYINITIAL); addToken(start,zzStartRead, Token.LITERAL_STRING_DOUBLE_QUOTE); }
	<<EOF>>				{ addToken(start,zzStartRead-1, Token.LITERAL_STRING_DOUBLE_QUOTE); addPhpEndToken(INTERNAL_IN_PHP_STRING); return firstToken; }
}


<PHP_CHAR> {
	[^\n\\\']+			{}
	\\.?				{ /* Skip escaped single quotes only, but this should still work. */ }
	\n					{ addToken(start,zzStartRead-1, Token.LITERAL_CHAR); addPhpEndToken(INTERNAL_IN_PHP_CHAR); return firstToken; }
	\'					{ yybegin(YYINITIAL); addToken(start,zzStartRead, Token.LITERAL_CHAR); }
	<<EOF>>				{ addToken(start,zzStartRead-1, Token.LITERAL_CHAR); addPhpEndToken(INTERNAL_IN_PHP_CHAR); return firstToken; }
}